<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Calculating driving distances using Open Source Routing Machine | Jacob T. Bradt</title> <meta name="author" content="Jacob T. Bradt"/> <meta name="description" content="A guide to running Open Source Routing Machine (OSRM) on AWS"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/UT_favicon.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jtbradt.github.io/blog/2022/osrm-aws/"> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> </head> <d-front-matter> <script async type="text/json">{
      "title": "Calculating driving distances using Open Source Routing Machine",
      "description": "A guide to running Open Source Routing Machine (OSRM) on AWS",
      "published": "June 1, 2022",
      "authors": [
        {
          "author": "Jake Bradt",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Harvard University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class=""> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://jtbradt.github.io/"><span class="font-weight-bold">Jacob</span> T. Bradt</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Calculating driving distances using Open Source Routing Machine</h1> <p>A guide to running Open Source Routing Machine (OSRM) on AWS</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#setting-up-your-aws-instance">Setting up your AWS instance</a></div> <div><a href="#setting-up-osrm">Setting up OSRM</a></div> <div><a href="#running-osrm-queries">Running OSRM queries</a></div> <div><a href="#example-r-code">Example R code</a></div> <div><a href="#final-product">Final product</a></div> </nav> </d-contents> <p>A while back I found myself needing to calculate driving distances and times between 30,744 origins and 408 destinations in the continental US. That’s a total of more than 12 million routes on a huge network! Ordinarily something like <a href="https://developers.google.com/maps/documentation/directions/overview" target="_blank" rel="noopener noreferrer">Google’s Directions API</a> would be helpful, but with the volume of routes and my grad student research budget this was not an option.</p> <p>Thankfully there’s a great product out there called <a href="http://project-osrm.org/" target="_blank" rel="noopener noreferrer">Open Source Routing Machine (OSRM)</a> that I was able to use for the task. Given the size of the road network I needed for my task, I did need to make use of virtual computing to run OSRM; however, I was able to do so at a tiny fraction of the cost of Google’s Directions API. Open-source for the win!</p> <p>Getting started took quite a bit of learning-by-doing. To provide positive learning-by-doing spillovers, I thought I would provide a brief<d-footnote>On second thought, maybe not so brief.</d-footnote> guide to setting up and running an OSRM server on an <a href="https://aws.amazon.com/" target="_blank" rel="noopener noreferrer">Amazon Web Services (AWS)</a> remote computing instance (and querying the server in R). OSRM is a valuable tool for calculating driving distances and times for a large number of origins and destinations at relatively low cost, particularly compared to other paid services such as the Google Map Direction API. OSRM is designed to be run using open source road network data from the <a href="https://www.openstreetmap.org/#map=4/38.01/-95.84" target="_blank" rel="noopener noreferrer">Open Street Map (OSM)</a> project; setting aside the fixed costs associated with learning how to use it, OSRM therefore provides a powerful routing option at no cost.</p> <p>Most applied researchers are likely interested in calculating driving distances and times for relatively large geographies. OSRM enables shortest path computation on continental-sized road networks; however, to do so requires sufficient memory and disk size and can take time to setup. If you are interested in, for example, calculating drive distances and times for the continental U.S., it is unlikely that you will have the technical requirements to do so locally. That’s why running OSRM on an AWS EC2 instance is a natural solution that adds minimal cost; fixed costs of learning how to use AWS aside, this is still far less expensive when running a large number of routes than paid services.</p> <p>I outline the complete process that I took to calculate drive distances and times for a complete matrix of origins and destinations in the continental U.S. via and AWS EC2 instance. Some or all of the below steps may or may not apply to you—free disposal of course applies so please use whatever is helpful in your application. Even if you, say, choose to use an alternative remote computing approach, the same general formula should still apply:</p> <ol> <li>Set up your remote instance (via AWS, etc.)</li> <li>Set up the OSRM server for your desired road network</li> <li>Run your queries!</li> </ol> <p>A few additional disclaimers. I am using a Mac running Mojave; if you are using a different operating system, the processes for accessing your AWS instance are likely to be different (thankfully AWS has ample documentation). I also made specific decisions on how to go about setting up the OSRM server on my instance—e.g., running a Linux OS on the instance, building OSRM using a Docker image, etc.—which are by no means the only way to go about doing this. I outline my rationale below, but alternative approaches may be better for your own purposes. Hopefully this resources is useful in your projects; if you have any questions, feel free to contact me by <a href="mailto:jbradt@g.harvard.edu">email</a>.</p> <h2 id="setting-up-your-aws-instance">Setting up your AWS instance</h2> <p>For my project calculating continental U.S. drive distances and durations, I ran the OSRM server on the entire U.S. road network (a very large network; the *.pbf file—more on this below—is 7.2 GB). To make sure that I had more than enough memory, I set up an m4.10xlarge instance. Generally, I think that an M4 instance is a good choice for this kind of task; AWS says that they provide a balance of compute, memory, and network resources. Your choice of a specific instance should depend on your memory/virtual CPU requirements. The table below shows the different M4 configurations (the full set of instance types is available <a href="https://aws.amazon.com/ec2/instance-types/" target="_blank" rel="noopener noreferrer">here</a>).</p> <table> <thead> <tr> <th>Instance</th> <th style="text-align: center">vCPU</th> <th style="text-align: center">Memory (GB)</th> </tr> </thead> <tbody> <tr> <td>m4.large</td> <td style="text-align: center">2</td> <td style="text-align: center">8</td> </tr> <tr> <td>m4.xlarge</td> <td style="text-align: center">4</td> <td style="text-align: center">16</td> </tr> <tr> <td>m4.2xlarge</td> <td style="text-align: center">8</td> <td style="text-align: center">32</td> </tr> <tr> <td>m4.4xlarge</td> <td style="text-align: center">16</td> <td style="text-align: center">64</td> </tr> <tr> <td>m4.10xlarge</td> <td style="text-align: center">40</td> <td style="text-align: center">160</td> </tr> <tr> <td>m4.16xlarge</td> <td style="text-align: center">64</td> <td style="text-align: center">256</td> </tr> </tbody> </table> <p>AWS offers two pricing schemes which depend on how you choose to schedule your EC2 usage: on-demand instances which allow you to use your instance whenever you like versus spot instances which allow you to make requests for spare EC2 computing capacity. You end up getting up to 90% off if you go the spot instance route. Additional info on pricing is available <a href="https://aws.amazon.com/ec2/pricing/" target="_blank" rel="noopener noreferrer">here</a>.</p> <p>Once you’ve decided which instance type and a pricing option is best for your project, the next key decision is which operating system you want to run on your instance. This will have important implications for implementing the steps that follow. I had my instance run the Amazon Linux AMI; this is the default and running Linux was helpful given that a lot of the OSRM backend support is geared towards Linux or Ubuntu OS.</p> <p>If you’re following the steps in this guide, I would suggest the default Amazon Linux AMI for your instance so that the specific steps included below are relevant to you. Once you’ve chosen an instance type, pricing option, and machine image, you are ready to get your instance up and running. But first you need to set up your key pair. This is the security credentials that you will use to prove your identity/access permissions when connecting to your instance. You can do so by following Amazon’s tutorial for EC2 key pairs and Linux instances: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#having-ec2-create-your-key-pair" target="_blank" rel="noopener noreferrer">Amazon EC2 key pairs and Linux instances</a>. I would recommend naming your key pair for this project something straightforward, like “osrm-instance” and make sure that you save it to a local directory you can easily navigate to via the command line as a *.pem file.<d-footnote>If you are using Windows OS locally and want to use a third party SSH client like PuTTY, you'll need to save your key as a *.ppk file. I think that new Windows OS already have an SSH client, OpenSSH. Since I run a Mac OS, I am not familiar with this client, but AWS has a helpful tutorial on connecting to Amazon Linux instances using any SSH client: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html. If you use OpenSSH on Windows, you should be able to use your key pair in the *.pem file format.</d-footnote> Note that you can only download a file storing your key pair once, so make sure you know which file format you need (see Footnote 3).</p> <p>Rather than copying directly from the AWS guides, here’s the link to a tutorial that walks you through the launch process for the Amazon Linux AMI: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html#ec2-launch-instance" target="_blank" rel="noopener noreferrer">Amazon Linux instance setup tutorial</a>.</p> <p>In step 4 of setting up your instance via the EC2 console, you’ll be asked to customize the elastic block storage with which your instance is launched. I added 128 GB of EBS, but I also ran a few projects using the OSRM server entirely remotely on my instance. This is not necessary if you follow the steps outlined below to run queries locally using the OSRM server you set up on your AWS instance. You will also be asked in step 6 to setup security groups. I would suggest setting up two TCP protocols, both specified to accept traffic from your IP address as the sole source: one standard port 22 protocol and the other a custom TCP protocol for port 5000; it will be important that port 5000 is open to your IP when it comes time to send queries to your OSRM server.<d-footnote>You can always add protocols after you launch your instance in the EC2 console.</d-footnote></p> <h2 id="setting-up-osrm">Setting up OSRM</h2> <p>Once your Amazon Linux instance is up and running, it is time to connect to it and begin setting up OSRM. I would encourage you to take a look at the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html" target="_blank" rel="noopener noreferrer">AWS tutorial</a> on connecting to your instance using an SSH client. This can be done from the command line when using Mac OS:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/directory_containing_pem
ssh <span class="nt">-i</span> <span class="s2">"osrm-instance.pem"</span> ec2-user@[Your Public DNS]</code></pre></figure> <p>The Public DNS for your instance is available in the EC2 console. An example (expired) Public DNS is “ec2-18-221-51-143.us-east-2.compute.amazonaws.com”.</p> <p>I think that the easiest way to build OSRM on your instance is to use Docker. The team behind OSRM publish ready to use lightweight Docker images for each OSRM release. This approach has several benefits. First, you don’t need to worry about cloning OSRM backend, which would require you to have a Github account and be prompted to enter your username and password. Using the Docker images also means that you don’t have to install the large number of tools and libraries required to build and run osrm-backend “native” on your EC2 instance. Additional info on the Docker images published by Project OSRM is available on the <a href="https://github.com/Project-OSRM/osrm-backend" target="_blank" rel="noopener noreferrer">Project-OSRM/osrm-backend Github page</a> and on the <a href="https://hub.docker.com/r/osrm/osrm-backend/" target="_blank" rel="noopener noreferrer">Project OSRM dockerhub page</a>. The OSRM backend Docker images are quite lightweight, so there’s little in the way of a tradeoff in terms of overhead for the ease of use that you get.</p> <p>To build osrm-backend using the latest published Docker image, first, set up Docker on your EC2 instance (<a href="https://docs.docker.com/" target="_blank" rel="noopener noreferrer">docker docs</a>). After connecting to your instance, you can execute the following steps via the command line to set up Docker:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">sudo </span>yum update <span class="nt">-y</span>
<span class="nb">sudo </span>yum <span class="nb">install </span>docker <span class="nt">-y</span>
<span class="nb">sudo </span>service docker start
<span class="nb">sudo </span>usermod <span class="nt">-a</span> <span class="nt">-G</span> docker ec2-user</code></pre></figure> <p>Docker should now be set up on your instance. You then need to log out and log back in so that your group membership is re-evaluated:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">exit
</span>ssh <span class="nt">-i</span> <span class="s2">"osrm-instance.pem"</span> ec2-user@[Your Public DNS]
docker info</code></pre></figure> <p>The final line checks that Docker is up and running. Now that you’re all set with Docker, the next step is to download/upload OpenStreetMap extracts to your instance. There are several ways of doing this, but by far the easiest is to use <a href="http://download.geofabrik.de/" target="_blank" rel="noopener noreferrer">Geofabrik</a>. Geofabrik offers easy downloads of OSM road networks for pretty much any aggregate geography you could want. In our case, it allows us to bypass downloading OSM networks locally and then uploading them to our instance: you can just fetch the data directly in your instance using the following command-line code:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">wget https://download.geofabrik.de/north-america/us-latest.osm.pbf</code></pre></figure> <p>Where this is fetching the latest OSM network for the entire US (about 7.2 GB). To find the download address for your desired geography, simply look for it on the <a href="http://download.geofabrik.de/" target="_blank" rel="noopener noreferrer">Geofabrik</a> site.</p> <p>Once you’ve fetched the relevant road network, it is time to pre-process the network extract. I assume that you are looking for driving directions and times, so we will do so with the car profile. To do so, execute the following commands separately:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-t</span> <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/data osrm/osrm-backend osrm-extract <span class="nt">-p</span> /opt/car.lua /data/us-latest.osm.pbf
docker run <span class="nt">-t</span> <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/data osrm/osrm-backend osrm-partition /data/us-latest.osrm
docker run <span class="nt">-t</span> <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/data osrm/osrm-backend osrm-customize /data/us-latest.osrm</code></pre></figure> <p>The first line creates an OSRM object from the downloaded road network using the car profile (can also switch to bicycle and walking profiles, but if you’re doing that you probably aren’t using large networks, can run OSRM locally, and don’t need this guide!). The second and third lines create the contraction hierarchies, which facilitate the shortest route between two points. Note that you will have to change “us-latest.osm.pbf” and “us-latest.osrm” in these commands to match the road network you are using. Each of these three commands will take a while to run, and total run time depends on the size of the road network you are using. Running this on the US road network took about 2-3 hours total.</p> <p>You are now almost ready to send routing queries to your OSRM server. The final step is to start a routing engine HTTP server on port 5000:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-t</span> <span class="nt">-i</span> <span class="nt">-p</span> 5000:5000 <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/data osrm/osrm-backend osrm-routed <span class="nt">--algorithm</span> mld /data/us-latest.osrm</code></pre></figure> <p>This final step should take a few moments, but at the end you will get the following message: “running and waiting for requests” — you’ve done it! Your OSRM server is up and running and ready to receive queries.</p> <p>Now that you’ve gone through the process of setting up your instance and getting your OSRM server up and running, you can exit your connection to your instance at any time and return to run additional queries when you want. To do so, simply re-connect to your instance and run the final command above that you used to start your routing engine HTTP server on port 5000.<d-footnote>NOTE: you will want to be considerate about the time that you keep your instance up and running (as opposed to paused or even terminated) as you will continue to be charged, certainly for the considerable amount of data that you may be storing on the EBS device that you've attached to your instance. I would encourage you to keep track of usage and charges via your AWS billing dashboard.</d-footnote></p> <h2 id="running-osrm-queries">Running OSRM queries</h2> <p>Now that your OSRM server is up and running, you can test to make sure it is running as expected by navigating to the following URL:</p> <figure class="highlight"><pre><code class="language-html" data-lang="html">http://your_server_ip:5000/route/v1/driving/13.388860,52.517037;13.385983,52.496891?steps=false</code></pre></figure> <p>where “your_server_ip” will be the Public DNS for your instance. You should get a JSON result if everything is running as expected.</p> <h2 id="example-r-code">Example R code</h2> <p>To get driving distances and durations for a large set of origin-destination pairs, I used the <a href="https://cran.r-project.org/web/packages/osrm/index.html" target="_blank" rel="noopener noreferrer">osrm R package</a> with the OSRM server option set to the IP address of the OSRM server I set up. Specifically, since I needed driving distances and durations from each origin to every destination for 30,744 origins and 408 destinations, I used the “osrmTable” function from the osrm R package, sending calls to the server in batches of 10 origins at a time. I’ve included the R function that I used to implement this as perhaps a helpful starting point for your own project.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#	Load packages:</span><span class="w">
</span><span class="n">pacman</span><span class="o">::</span><span class="n">p_load</span><span class="p">(</span><span class="n">data.table</span><span class="p">,</span><span class="w"> </span><span class="n">dplyr</span><span class="p">,</span><span class="w"> </span><span class="n">tidyr</span><span class="p">,</span><span class="w"> </span><span class="n">osrm</span><span class="p">,</span><span class="w"> </span><span class="n">parallel</span><span class="p">,</span><span class="w"> </span><span class="n">rlist</span><span class="p">)</span><span class="w">

</span><span class="c1">#	Function to batch generate large driving distance and duration matrices using specified OSRM server:</span><span class="w">
</span><span class="n">drive.distance</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">origin.file</span><span class="p">,</span><span class="w"> </span><span class="n">dest.file</span><span class="p">,</span><span class="w"> </span><span class="n">chunk.size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">num.cores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">output.dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
	
	</span><span class="c1">#	Load origins data:</span><span class="w">
	</span><span class="n">origin.data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">origin.file</span><span class="p">)</span><span class="w">
	
	</span><span class="c1">#	Split origins data into chunks:</span><span class="w">
	</span><span class="n">nr.origin</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">origin.data</span><span class="p">)</span><span class="w">
	</span><span class="n">origin.chunks</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">split</span><span class="p">(</span><span class="n">origin.data</span><span class="p">,</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">ceiling</span><span class="p">(</span><span class="n">nr.origin</span><span class="o">/</span><span class="n">chunk.size</span><span class="p">),</span><span class="w"> </span><span class="n">each</span><span class="o">=</span><span class="n">chunk.size</span><span class="p">,</span><span class="w"> </span><span class="n">length.out</span><span class="o">=</span><span class="n">nr.origin</span><span class="p">))</span><span class="w">
	
	</span><span class="c1">#	Import destination data:</span><span class="w">
	</span><span class="n">dest.data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">dest.file</span><span class="p">)</span><span class="w">
	
	</span><span class="c1">#	Set OSRM related options:</span><span class="w">
	</span><span class="n">options</span><span class="p">(</span><span class="n">osrm.server</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">osrm.profile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"driving"</span><span class="p">)</span><span class="w">
	
	</span><span class="c1">#	Generate duration and distance matrices for each origin and destination pair:</span><span class="w">
	</span><span class="n">matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mclapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">origin.chunks</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="w">
		</span><span class="n">osrmTable</span><span class="p">(</span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin.chunks</span><span class="p">[[</span><span class="n">x</span><span class="p">]],</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dest.data</span><span class="p">,</span><span class="w"> </span><span class="n">measure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s1">'duration'</span><span class="p">,</span><span class="w"> </span><span class="s1">'distance'</span><span class="p">))</span><span class="w">
	</span><span class="p">},</span><span class="w"> </span><span class="n">mc.cores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num.cores</span><span class="p">)</span><span class="w">
	
	</span><span class="c1">#	Construct duration matrix:</span><span class="w">
	</span><span class="n">durations</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="n">x</span><span class="o">$</span><span class="n">durations</span><span class="p">})</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
		</span><span class="n">do.call</span><span class="p">(</span><span class="n">rbind</span><span class="p">,</span><span class="n">.</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
		</span><span class="n">data.table</span><span class="p">(</span><span class="n">.</span><span class="p">)</span><span class="w">
	</span><span class="n">durations</span><span class="p">[,</span><span class="n">origin.id</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">origin.data</span><span class="o">$</span><span class="n">origin.id</span><span class="p">]</span><span class="w">
	
	</span><span class="c1">#	Construct distance matrix:</span><span class="w">
	</span><span class="n">distances</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="n">x</span><span class="o">$</span><span class="n">distances</span><span class="p">})</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
		</span><span class="n">do.call</span><span class="p">(</span><span class="n">rbind</span><span class="p">,</span><span class="n">.</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
		</span><span class="n">data.table</span><span class="p">(</span><span class="n">.</span><span class="p">)</span><span class="w">
	</span><span class="n">distances</span><span class="p">[,</span><span class="n">origin.id</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">origin.data</span><span class="o">$</span><span class="n">origin.id</span><span class="p">]</span><span class="w">
	
	</span><span class="c1">#	If requested, write files to given directory:</span><span class="w">
	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nf">is.null</span><span class="p">(</span><span class="n">output.dir</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="n">output1.filename</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="n">output.dir</span><span class="p">,</span><span class="w"> </span><span class="s2">"driving_durations.csv"</span><span class="p">)</span><span class="w">
		</span><span class="n">output2.filename</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="n">output.dir</span><span class="p">,</span><span class="w"> </span><span class="s2">"driving_distances.csv"</span><span class="p">)</span><span class="w">
		</span><span class="n">fwrite</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span><span class="w"> </span><span class="n">output1.filename</span><span class="p">)</span><span class="w">
		</span><span class="n">fwrite</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span><span class="w"> </span><span class="n">output2.filename</span><span class="p">)</span><span class="w">
	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span><span class="w"> </span><span class="n">durations</span><span class="p">))</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="final-product">Final product</h2> <p>If you made it this far, the least I can do is show you a pretty(ish) picture. Below is the final product. Note that the above steps actually only produced half of the below image—I also needed to calculate expected flight costs for each of my origin-destination pairs which could be the topic of several other blog posts. But anyways, everyone loves a picture!</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/fig_costs-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/fig_costs-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/fig_costs-1400.webp"></source> <img src="/assets/img/fig_costs.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> &lt;/div&gt; &lt;/div&gt; <div class="caption"> Relationship between estimated driving, flying and expected travel costs and one-way driving distance for my origin-destination pairs. Flight probabilities come from https://doi.org/10.1016/j.jeem.2018.06.010 </div> </figure> </div> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2026 Jacob T. Bradt. Please send comments or questions to <a href="mailto:jacob.bradt@austin.utexas.edu">jacob.bradt@austin.utexas.edu</a>. </div> </footer> </body> <d-bibliography src="/assets/bibliography/"> </d-bibliography> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/overrides.js"></script> </html>